#from optic.models.devices import mzm, pm
from optic.utils import parameters
import numpy as np
import torch.distributions.uniform as urand
from scipy.optimize import minimize

import torch

π = torch.pi

class parameters():
    pass


def pm(Ai, u, Vπ):

    # calculate the output
    Ao = Ai * torch.cos(u / Vπ * torch.pi) + 1j * Ai * torch.sin(u / Vπ * torch.pi)
    
    return Ao

def mzm(Ai, u, Vπ, Vb):

    # calculate the output
    Ao = Ai * torch.cos(0.5 / Vπ * (u + Vb) * torch.pi)

    return Ao


def ddmzm(Ai, u1, u2, Vb1, Vb2, Vπ):

    # calculate the output
    Ao = 0.5 * Ai * (pm(1, u1 + Vb1, Vπ) + pm(1, u2 + Vb2, Vπ))

    return Ao

def frequencyCombGenerator_MZM_MZM_PM(params, Rs, t, P, Vπ):

    '''
    This function generates a frequency comb signal using two MZMs and a PM.
    
    Parameters:
    V1, V2, V3: float
        Amplitude of the signals (V)
    Phase1, Phase2, Phase3: float
        Phase of the signals (rad)
    Vb1, Vb2: float
        Bias voltage of the MZMs (V)

    Returns:
    frequency_comb: array
        Frequency comb signal
    '''
    V1, V2, V3, Phase1, Phase2, Phase3, Vb2, Vb3 = params.T

    t = t.view(1, -1)  # Reshape t to [1, T] for broadcasting

    u1 = V1.unsqueeze(1) * torch.cos(2 * torch.pi * Rs * t + Phase1.unsqueeze(1))
    u2 = V2.unsqueeze(1) * torch.cos(2 * torch.pi * Rs * t + Phase2.unsqueeze(1))
    u3 = V3.unsqueeze(1) * torch.cos(2 * torch.pi * Rs * t + Phase3.unsqueeze(1))

    frequency_comb = P
    frequency_comb =  pm(frequency_comb, u1, Vπ)
    frequency_comb = mzm(frequency_comb, u2, Vπ, Vb2.unsqueeze(1))
    frequency_comb = mzm(frequency_comb, u3, Vπ, Vb3.unsqueeze(1))

    return frequency_comb


def frequencyCombGenerator_PM_PM_MZM(params, Rs, t, P, Vπ):

    '''
    This function generates a frequency comb signal using two MZMs and a PM.
    
    Parameters:
    V1, V2, V3: float
        Amplitude of the signals (V)
    Phase1, Phase2, Phase3: float
        Phase of the signals (rad)
    Vb1, Vb2: float
        Bias voltage of the MZMs (V)

    Returns:
    frequency_comb: array
        Frequency comb signal
    '''
    V1, V2, V3, Phase1, Phase2, Phase3, Vb3 = params.T

    t = t.view(1, -1)  # Reshape t to [1, T] for broadcasting

    u1 = V1.unsqueeze(1) * torch.cos(2 * torch.pi * Rs * t + Phase1.unsqueeze(1))
    u2 = V2.unsqueeze(1) * torch.cos(2 * torch.pi * Rs * t + Phase2.unsqueeze(1))
    u3 = V3.unsqueeze(1) * torch.cos(2 * torch.pi * Rs * t + Phase3.unsqueeze(1))

    frequency_comb = P
    frequency_comb =  pm(frequency_comb, u1, Vπ)
    frequency_comb =  pm(frequency_comb, u2, Vπ)
    frequency_comb = mzm(frequency_comb, u3, Vπ, Vb3.unsqueeze(1))

    return frequency_comb


def frequencyCombGenerator_DDMZM(params, Rs, t, P, Vπ):
    ''' 
    This function generates a frequency comb using a dual-drive Mach-Zehnder modulator (DD-MZM)

    Parameters:
    V1 : float
        Amplitude of the signal for the first modulator (V)
    V2 : float
        Amplitude of the signal for the second modulator (V)
    Phase1 : float
        Phase of the signal for the first modulator (rad)
    Phase2 : float
        Phase of the signal for the second modulator (rad)
    Vb1 : float
        Bias voltage for the first modulator (V)
    Vb2 : float
        Bias voltage for the second modulator (V)

    Returns:
    frequency_comb : array
        Frequency comb generated by the DDMZM (W)

    '''
    V1, V2, Phase1, Phase2, Vb1, Vb2 = params.T

    t = t.view(1, -1)  # Reshape t to [1, T] for broadcasting

    u1 = V1.unsqueeze(1) * torch.cos(2 * π * Rs * t + Phase1.unsqueeze(1))
    u2 = V2.unsqueeze(1) * torch.cos(2 * π * Rs * t + Phase2.unsqueeze(1))
    
    frequency_comb = ddmzm(P, u1, u2, Vb1.unsqueeze(1), Vb2.unsqueeze(1), Vπ)

    return frequency_comb

def get_psd_ByFFT(signal, Fa, NFFT = 16*1024):
    '''
    Calculate the Power Spectral Density (PSD) of a signal using FFT in PyTorch.

    Parameters:
    signal: torch.Tensor
        Signal to calculate the PSD
    Fa: float
        Sampling frequency of the signal (samples per second)
    NFFT: int
        Number of points of the FFT (default is 16*1024)
        
    Returns:
    psd: torch.Tensor
        Power Spectral Density of the signal
    freqs: torch.Tensor
        Frequencies of the PSD    
    '''

    fft_result = torch.fft.fftshift(torch.fft.fft(signal, n=NFFT, dim=-1), dim=-1)  # get the fft
    power_spectrum = torch.abs(fft_result) ** 2  # get the power spectrum
    psd = power_spectrum / (NFFT * Fa)  # get the power spectral density
    #psd = torch.clamp(psd, min=torch.finfo(psd.dtype).eps)  # to avoid log(0) issues
    psd[psd == 0] = torch.finfo(psd.dtype).eps # to avoid log(0) issues
    freqs = torch.fft.fftshift(torch.fft.fftfreq(NFFT, 1 / Fa)).to(psd.device) # get the frequencies

    return psd, freqs


def get_indx_peaks(log_Pxx, SpRs, n_peaks):
    '''
    Function to get the indexes of the peaks in the power spectrum of the frequency comb signal

    Parameters:
    log_Pxx: torch array
        Power spectrum of the frequency comb signal
    SpRs: int
        Samples by each Rs. Each peak is separated by the Rs frequency. SpRs = (NFFT/SpS)
    n_peaks: int
        Number of peaks to be found

    Returns:
    indx: list
        Indexes of the peaks in the power spectrum of the frequency comb signal
    '''

    center_indx = log_Pxx.size(-1) // 2  # get the center index
    offsets = torch.arange(-(n_peaks // 2), (n_peaks // 2) + 1, device=log_Pxx.device) * SpRs  # create an array of offsets for the peaks
    offsets = offsets.to(torch.int)  # Ensure offsets are integers
    indx = center_indx + offsets  # calculate the indices of the peaks
    peaks = log_Pxx[:, indx].squeeze()  # extract the peaks from log_Pxx

    return peaks, indx

def frequencyCombPeaks(params, args):
    ''' 
    Function to get the peaks of the power spectrum of the frequency comb signal

    Parameters:
    params: list
        Parameters to generate the frequency comb signal
    args: parameters
        Parameters object with the arguments to generate the frequency comb signal
        Should contain the following attributes: Rs, t, P, Vπ, Fa, NFFT, SpS, n_peaks

    Returns:
    peaks: list
        Peaks of the power spectrum of the frequency comb signal
    '''
    
    frequency_comb = frequencyCombGenerator_MZM_MZM_PM(params, args.Rs, args.t, args.P, args.Vpi) # Generate the frequency comb signal
    #frequency_comb = frequencyCombGenerator_PM_PM_MZM(params, args.Rs, args.t, args.P, args.Vpi) # Generate the frequency comb signal
    Pxx, _ = get_psd_ByFFT(frequency_comb, args.Fa, args.NFFT) # Get the power spectrum of the frequency comb signal
    log_Pxx = 10*torch.log10(Pxx) # Convert the power spectrum to dB
    peaks, _ = get_indx_peaks(log_Pxx, args.NFFT/args.SpS, args.n_peaks) # Get the indexes of the peaks

    return peaks

def analitical_function(params, args):

    # Split params into individual components
    V1, V2, V3, Phase1, Phase2, Phase3, Vb2, Vb3 = params.T

    # Calculate u1, u2, u3 with broadcasting
    t = args.t.view(1, -1)  # Reshape t to [1, T] for broadcasting

    u1 = V1.unsqueeze(1) * torch.cos(2 * torch.pi * args.Rs * t + Phase1.unsqueeze(1))
    u2 = V2.unsqueeze(1) * torch.cos(2 * torch.pi * args.Rs * t + Phase2.unsqueeze(1))
    u3 = V3.unsqueeze(1) * torch.cos(2 * torch.pi * args.Rs * t + Phase3.unsqueeze(1))

    # Calculate frequency_comb pm -> mzm -> mzm
    K = torch.pi / args.Vpi
    frequency_comb = args.P 
    frequency_comb = frequency_comb * (torch.cos(u1 * K) + 1j * torch.sin(u1 * K))  # pm
    frequency_comb = frequency_comb * torch.cos((0.5 * (u2 + Vb2.unsqueeze(1))) * K)  # mzm
    frequency_comb = frequency_comb * torch.cos((0.5 * (u3 + Vb3.unsqueeze(1))) * K)  # mzm

    # Calculate FFT and power spectrum
    fft_result = torch.fft.fftshift(torch.fft.fft(frequency_comb, n=args.NFFT, dim=-1), dim=-1)  # get the fft
    power_spectrum = torch.abs(fft_result) ** 2  # get the power spectrum
    psd = power_spectrum / (args.NFFT * args.Fa)  # get the power spectral density
    psd = torch.clamp(psd, min=torch.finfo(psd.dtype).eps)  # to avoid log(0) issues
    log_Pxx = 10 * torch.log10(psd)

    # Calculate peak indices
    SpRs = args.NFFT // args.SpS
    center_indx = log_Pxx.size(-1) // 2  # get the center index
    offsets = torch.arange(-(args.n_peaks // 2), (args.n_peaks // 2) + 1, device=params.device) * SpRs  # create an array of offsets for the peaks
    indx = center_indx + offsets  # calculate the indices of the peaks

    # Gather peaks
    peaks = log_Pxx[:, indx].squeeze()  # extract the peaks from log_Pxx

    return peaks


def optimization_flatComb(initial_guess, args, bounds, n_max = 100, method = "SLSQP"):
    ''' 
    Function to optimize the parameters of the frequency comb signal

    Parameters:
    initial_guess: list
        Initial guess for the parameters of the frequency comb signal
    args: parameters()
        Parameters object with the arguments to generate the frequency comb signal
        Should contain the following attributes: Rs, t, P, Vpi, Fa, NFFT, SpS, n_peaks
    bounds: list
        Bounds of the parameters
    n_max: int
        Max number of iterations
    method: string
        Optimization method: Nelder-Mead, Powell, L-BFGS-B, TNC, COBYLA, SLSQP, trust-constr

    Returns:
    optimized_params: list
        Optimized parameters of the frequency comb signal
    '''

    def objective_function(params, *args):

        peaks = frequencyCombPeaks(params, *args)
        var = torch.var(peaks).numpy()
        
        return var**2
    
    optimized_params = initial_guess
    n = 0
    while n < n_max:
        initial_guess = optimized_params
        result = minimize(objective_function, initial_guess, args = args, method=method, bounds = bounds)
        optimized_params = result.x
        
        peaks = frequencyCombPeaks(optimized_params, args)
        min_max = np.max(peaks.numpy()) - np.min(peaks.numpy())

        if min_max < 1:
            break
        n += 1

    return optimized_params, peaks, min_max


def create_flatCombs(nsamples, args, bounds, upper_min_max = 5.0, n_max = 100, method = "COBYLA"):
    '''
    Function to create the flatComb datasets

    Parameters:
    nsamples: int
        Number of samples to be created
    bounds: list
        Bounds of the parameters
    upper_min_max: float
        Maximum value of the peaks variance

    Returns:
    flatComb_inputs0_1dB: list
        Inputs of the flatComb dataset with peaks variance less than 1 dB
    flatComb_outputs0_1dB: list
        Outputs of the flatComb dataset with peaks variance less than 1 dB
    flatComb_inputs1_ndB: list
        Inputs of the flatComb dataset with peaks variance between 1 and n dB, where n is the upper_min_max
    flatComb_outputs1_ndB: list
        Outputs of the flatComb dataset with peaks variance between 1 and n dB, where n is the upper_min_max
        
    '''
    inputs = [[urand.Uniform(low, high).sample().item() for low, high in bounds] for _ in range(nsamples)]

    flatComb_inputs0_1dB = []
    flatComb_outputs0_1dB = []

    flatComb_inputs1_ndB = []
    flatComb_outputs1_ndB = []

    for input in inputs:
        best_params, peaks, min_max = optimization_flatComb(input, args, bounds, n_max, method)
        if min_max < 1:
            flatComb_inputs0_1dB.append(best_params.tolist())
            peaks = peaks - torch.mean(peaks)
            flatComb_outputs0_1dB.append(peaks.tolist())
        elif min_max < upper_min_max:
            flatComb_inputs1_ndB.append(best_params.tolist())
            peaks = peaks - torch.mean(peaks)
            flatComb_outputs1_ndB.append(peaks.tolist())


    print(flatComb_inputs0_1dB)
    print(flatComb_outputs0_1dB)
    flatComb_inputs0_1dB = torch.as_tensor(flatComb_inputs0_1dB)
    flatComb_outputs0_1dB = torch.as_tensor(flatComb_outputs0_1dB)

    flatComb_inputs1_ndB = torch.as_tensor(flatComb_inputs1_ndB)
    flatComb_outputs1_ndB = torch.as_tensor(flatComb_outputs1_ndB)

    return flatComb_inputs0_1dB, flatComb_outputs0_1dB, flatComb_inputs1_ndB, flatComb_outputs1_ndB
