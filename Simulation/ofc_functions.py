#from optic.models.devices import mzm, pm
#from optic.utils import parameters
import numpy as np
import torch.distributions.uniform as urand
from scipy.optimize import minimize

import torch
from torch.cuda.amp import autocast

π = torch.pi

class parameters():
    pass


def pm(Ai, u, Vπ):

    # calculate the output
    Ao = Ai * torch.cos(u / Vπ * torch.pi) + 1j * Ai * torch.sin(u / Vπ * torch.pi)
    
    return Ao

def mzm(Ai, u, Vπ, Vb):

    # calculate the output
    Ao = Ai * torch.cos(0.5 / Vπ * (u + Vb) * torch.pi)

    return Ao


def ddmzm(Ai, u1, u2, Vb1, Vb2, Vπ):

    # calculate the output
    Ao = 0.5 * Ai * (pm(1, u1 + Vb1, Vπ) + pm(1, u2 + Vb2, Vπ))

    return Ao

def frequencyCombGenerator_MZM_MZM_PM(params, Rs, t, P, Vπ):

    '''
    This function generates a frequency comb signal using a PM and two MZMs.
    
    Parameters:

    params: torch.Tensor
        Parameters to generate the frequency comb signal
        params.V1, params.V2, params.V3: float
            Amplitude of the signals (V)
        params.Phase1, params.Phase2, params.Phase3: float
            Phase of the signals (rad)
        params.Vb2, params.Vb3: float
            Bias voltage of the MZMs (V)
    Rs: float
        Symbol rate (samples per second)
    t: torch.Tensor
        Time vector
    P: float
        Power of the frequency comb signal (W)
    Vπ: float
        Half-wave voltage of the MZM (V)

    Returns:
    frequency_comb: array
        Frequency comb signal
    '''
    V1, V2, V3, Phase1, Phase2, Phase3, Vb2, Vb3 = params.T

    t = t.unsqueeze(0).to(params.device)  # Reshape t to [1, T] for broadcasting
    V1 = V1.unsqueeze(1)
    V2 = V2.unsqueeze(1)
    V3 = V3.unsqueeze(1)
    Phase1 = Phase1.unsqueeze(1)
    Phase2 = Phase2.unsqueeze(1)
    Phase3 = Phase3.unsqueeze(1)
    Vb2 = Vb2.unsqueeze(1)
    Vb3 = Vb3.unsqueeze(1)

    u1 = V1 * torch.cos(2 * torch.pi * Rs * t + Phase1)
    u2 = V2 * torch.cos(2 * torch.pi * Rs * t + Phase2)
    u3 = V3 * torch.cos(2 * torch.pi * Rs * t + Phase3)

    frequency_comb = P
    frequency_comb =  pm(frequency_comb, u1, Vπ)
    frequency_comb = mzm(frequency_comb, u2, Vπ, Vb2)
    frequency_comb = mzm(frequency_comb, u3, Vπ, Vb3)

    return frequency_comb


def frequencyCombGenerator_PM_PM_MZM(params, Rs, t, P, Vπ):

    '''
    This function generates a frequency comb signal using two PMs and a MZM.
    
    Parameters:

    params: torch.Tensor
        Parameters to generate the frequency comb signal
        params.V1, params.V2, params.V3: float
            Amplitude of the signals (V)
        params.Phase1, params.Phase2, params.Phase3: float
            Phase of the signals (rad)
        params.Vb3: float
            Bias voltage of the MZM (V)
    Rs: float
        Symbol rate (samples per second)
    t: torch.Tensor
        Time vector
    P: float
        Power of the frequency comb signal (W)
    Vπ: float
        Half-wave voltage of the MZM (V)

    Returns:
    frequency_comb: array
        Frequency comb signal
    '''
    V1, V2, V3, Phase1, Phase2, Phase3, Vb3 = params.T

    t = t.unsqueeze(0).to(params.device)  # Reshape t to [1, T] for broadcasting
    V1 = V1.unsqueeze(1)
    V2 = V2.unsqueeze(1)
    V3 = V3.unsqueeze(1)
    Phase1 = Phase1.unsqueeze(1)
    Phase2 = Phase2.unsqueeze(1)
    Phase3 = Phase3.unsqueeze(1)
    Vb3 = Vb3.unsqueeze(1)

    u1 = V1 * torch.cos(2 * torch.pi * Rs * t + Phase1)
    u2 = V2 * torch.cos(2 * torch.pi * Rs * t + Phase2)
    u3 = V3 * torch.cos(2 * torch.pi * Rs * t + Phase3)

    frequency_comb = P
    frequency_comb =  pm(frequency_comb, u1, Vπ)
    frequency_comb =  pm(frequency_comb, u2, Vπ)
    frequency_comb = mzm(frequency_comb, u3, Vπ, Vb3)

    return frequency_comb


def frequencyCombGenerator_DDMZM(params, Rs, t, P, Vπ):
    ''' 
    This function generates a frequency comb using a dual-drive Mach-Zehnder modulator (DD-MZM)

    Parameters:
    V1 : float
        Amplitude of the signal for the first modulator (V)
    V2 : float
        Amplitude of the signal for the second modulator (V)
    Phase1 : float
        Phase of the signal for the first modulator (rad)
    Phase2 : float
        Phase of the signal for the second modulator (rad)
    Vb1 : float
        Bias voltage for the first modulator (V)
    Vb2 : float
        Bias voltage for the second modulator (V)

    Returns:
    frequency_comb : array
        Frequency comb generated by the DDMZM (W)

    '''
    V1, V2, Phase1, Phase2, Vb1, Vb2 = params.T

    t = t.unsqueeze(0).to(params.device)  # Reshape t to [1, T] for broadcasting
    V1 = V1.unsqueeze(1)
    V2 = V2.unsqueeze(1)
    Phase1 = Phase1.unsqueeze(1)
    Phase2 = Phase2.unsqueeze(1)
    Vb1 = Vb1.unsqueeze(1)
    Vb2 = Vb2.unsqueeze(1)

    u1 = V1 * torch.cos(2 * torch.pi * Rs * t + Phase1)
    u2 = V2 * torch.cos(2 * torch.pi * Rs * t + Phase2)
    
    frequency_comb = ddmzm(P, u1, u2, Vb1, Vb2, Vπ)

    return frequency_comb

def get_psd_ByFFT(signal, Fa, NFFT = 16*1024):
    '''
    Calculate the Power Spectral Density (PSD) of a signal using FFT in PyTorch.

    Parameters:
    signal: torch.Tensor
        Signal to calculate the PSD
    Fa: float
        Sampling frequency of the signal (samples per second)
    NFFT: int
        Number of points of the FFT (default is 16*1024)
        
    Returns:
    psd: torch.Tensor
        Power Spectral Density of the signal
    freqs: torch.Tensor
        Frequencies of the PSD    
    '''

    fft_result = torch.fft.fftshift(torch.fft.fft(signal, n=NFFT, dim=-1), dim=-1)  # get the fft
    power_spectrum = torch.abs(fft_result) ** 2  # get the power spectrum
    psd = power_spectrum / (NFFT * Fa)  # get the power spectral density
    psd[psd == 0] = torch.finfo(psd.dtype).eps # to avoid log(0) issues
    freqs = torch.fft.fftshift(torch.fft.fftfreq(NFFT, 1 / Fa)).to(psd.device) # get the frequencies

    return psd, freqs


def get_indx_peaks(log_Pxx, SpRs, n_peaks):
    '''
    Function to get the indexes of the peaks in the power spectrum of the frequency comb signal

    Parameters:
    log_Pxx: torch array
        Power spectrum of the frequency comb signal
    SpRs: int
        Samples by each Rs. Each peak is separated by the Rs frequency. SpRs = (NFFT/SpS)
    n_peaks: int
        Number of peaks to be found

    Returns:
    indx: list
        Indexes of the peaks in the power spectrum of the frequency comb signal
    '''

    center_indx = log_Pxx.size(-1) // 2  # get the center index
    offsets = torch.arange(-(n_peaks // 2), (n_peaks // 2) + 1, device=log_Pxx.device) * SpRs  # create an array of offsets for the peaks
    offsets = offsets.to(torch.int)  # Ensure offsets are integers
    indx = center_indx + offsets  # calculate the indices of the peaks
    peaks = log_Pxx[:, indx]  # extract the peaks from log_Pxx

    return peaks, indx

def frequencyCombPeaks(params, args):
    ''' 
    Function to get the peaks of the power spectrum of the frequency comb signal

    Parameters:
    params: torch.Tensor
        Parameters to generate the frequency comb signal
    args: parameters
        Parameters object with the arguments to generate the frequency comb signal
        Should contain the following attributes: t, Rs, Vpi, P, NFFT, Fa, SpS, n_peaks
        args.t: torch.Tensor
            Time vector
        args.Rs: float
            Symbol rate (samples per second)
        args.Vpi: float
            Half-wave voltage of the MZM (V)
        args.P: float
            Power of the frequency comb signal (W)
        args.NFFT: int
            Number of points of the FFT (multiple of SpS)
        args.Fa: float
            Sampling frequency of the signal (samples per second)
        args.SpS: int
            Samples by each Rs
        args.n_peaks: int
            Number of peaks to be found (odd number)

    Returns:
    peaks: torch.Tensor
        Peaks of the power spectrum of the frequency comb signal
    '''
    
    frequency_comb = frequencyCombGenerator_MZM_MZM_PM(params, args.Rs, args.t, args.P, args.Vpi) # Generate the frequency comb signal
    #frequency_comb = frequencyCombGenerator_PM_PM_MZM(params, args.Rs, args.t, args.P, args.Vpi) # Generate the frequency comb signal
    Pxx, _ = get_psd_ByFFT(frequency_comb, args.Fa, args.NFFT) # Get the power spectrum of the frequency comb signal
    log_Pxx = 10*torch.log10(Pxx) # Convert the power spectrum to dB
    peaks, _ = get_indx_peaks(log_Pxx, args.NFFT/args.SpS, args.n_peaks) # Get the indexes of the peaks

    return peaks


def analytical_function_compact(params, args):
    '''
    Function to generate the frequency comb signal peaks of PM-MZM-MZM

    Parameters:
    params: torch.Tensor
        Parameters to generate the frequency comb signal
    args: parameters
        Parameters object with the arguments to generate the frequency comb signal
        Should contain the following attributes: t, Rs, Vpi, P, NFFT, Fa, SpS, n_peaks
        args.t: torch.Tensor
            Time vector
        args.Rs: float
            Symbol rate (samples per second)
        args.Vpi: float
            Half-wave voltage of the MZM (V)
        args.P: float
            Power of the frequency comb signal (W)
        args.NFFT: int
            Number of points of the FFT (multiple of SpS)
        args.Fa: float
            Sampling frequency of the signal (samples per second)
        args.SpS: int
            Samples by each Rs
        args.n_peaks: int
            Number of peaks to be found (odd number)

    Returns:
    peaks: torch.Tensor
        Peaks of the power spectrum of the frequency comb signal

    '''
    V1, V2, V3, Phase1, Phase2, Phase3, Vb2, Vb3 = [p.contiguous() for p in params.T]
    t = args.t.unsqueeze(0)
    pi_Rs_t = 2 * torch.pi * args.Rs * t
    K = torch.pi / args.Vpi
    u1 = V1.unsqueeze(1) * torch.cos(pi_Rs_t + Phase1.unsqueeze(1))
    u2 = V2.unsqueeze(1) * torch.cos(pi_Rs_t + Phase2.unsqueeze(1))
    u3 = V3.unsqueeze(1) * torch.cos(pi_Rs_t + Phase3.unsqueeze(1))
    cos_u1_K, sin_u1_K = torch.cos(u1 * K), torch.sin(u1 * K)
    cos_u2_Vb2_K = torch.cos((0.5 * (u2 + Vb2.unsqueeze(1))) * K)
    cos_u3_Vb3_K = torch.cos((0.5 * (u3 + Vb3.unsqueeze(1))) * K)
    frequency_comb = args.P * (cos_u1_K + 1j * sin_u1_K) * cos_u2_Vb2_K * cos_u3_Vb3_K
    psd = torch.fft.fft(frequency_comb, n=args.NFFT, dim=-1)
    psd = torch.fft.fftshift(psd, dim=-1)
    psd = torch.abs(psd) ** 2 / (args.NFFT * args.Fa)
    psd[psd == 0] = torch.finfo(psd.dtype).eps
    log_Pxx = 10 * torch.log10(psd)
    n_peaks_2 = args.n_peaks // 2
    indx = (log_Pxx.size(-1) // 2) + torch.arange(-n_peaks_2, n_peaks_2 + 1, device=params.device).to(torch.int) * (args.NFFT // args.SpS)
    peaks = torch.index_select(log_Pxx, 1, indx)
    return peaks


@torch.jit.script
def analytical_function_jit(params, t, Rs, Vpi, P, NFFT, Fa, SpS, n_peaks):

    '''
    Function to generate the frequency comb signal peaks of PM-MZM-MZM using JIT

    Parameters:
    params: torch.Tensor
        Parameters to generate the frequency comb signal
    t: torch.Tensor
        Time vector
    Rs: torch.Tensor
        Symbol rate (samples per second)
    Vpi: torch.Tensor
        Half-wave voltage of the MZM (V)
    P: torch.Tensor
        Power of the frequency comb signal (W)
    NFFT: torch.Tensor
        Number of points of the FFT
    Fa: torch.Tensor
        Sampling frequency of the signal (samples per second)
    SpS: torch.Tensor
        Samples by each Rs
    n_peaks: torch.Tensor
        Number of peaks to be found

    Returns:
    peaks: torch.Tensor
        Peaks of the power spectrum of the frequency comb signal
    '''
    V1, V2, V3, Phase1, Phase2, Phase3, Vb2, Vb3 = [p.contiguous() for p in params.T]

    t = t.unsqueeze(0)
    pi_Rs_t = 2 * torch.pi * Rs * t
    K = torch.pi / Vpi

    with autocast(enabled=True):
        u1 = V1.unsqueeze(1) * torch.cos(pi_Rs_t + Phase1.unsqueeze(1))
        u2 = V2.unsqueeze(1) * torch.cos(pi_Rs_t + Phase2.unsqueeze(1))
        u3 = V3.unsqueeze(1) * torch.cos(pi_Rs_t + Phase3.unsqueeze(1))
        cos_u1_K = torch.cos(u1 * K)
        sin_u1_K = torch.sin(u1 * K)
        cos_u2_Vb2_K = torch.cos((0.5 * (u2 + Vb2.unsqueeze(1))) * K)
        cos_u3_Vb3_K = torch.cos((0.5 * (u3 + Vb3.unsqueeze(1))) * K)
        real_part = P * cos_u1_K * cos_u2_Vb2_K * cos_u3_Vb3_K
        imag_part = P * sin_u1_K * cos_u2_Vb2_K * cos_u3_Vb3_K
        frequency_comb = torch.complex(real_part, imag_part)

        psd = torch.fft.fft(frequency_comb, n=NFFT, dim=-1)
        psd = torch.fft.fftshift(psd, dim=-1)
        psd = torch.abs(psd) ** 2 / (NFFT * Fa)
        psd[psd == 0] = 1e-8 # torch.finfo(psd.dtype).eps
        log_Pxx = 10 * torch.log10(psd)

    n_peaks_2 = n_peaks // 2
    indx = (log_Pxx.size(-1) // 2) + torch.arange(-n_peaks_2, n_peaks_2 + 1, device=params.device).to(torch.int) * (NFFT // SpS)
    peaks = torch.index_select(log_Pxx, 1, indx)

    return peaks


def analytical_function_compact_numpy(params, args):
    '''
    Function to generate the frequency comb signal peaks of PM-MZM-MZM using NumPy

    Parameters:
    params: list
        Parameters to generate the frequency comb signal
    args: parameters
        Parameters object with the arguments to generate the frequency comb signal
        Should contain the following attributes: t, Rs, Vpi, P, NFFT, Fa, SpS, n_peaks
        args.t: numpy array
            Time vector
        args.Rs: float
            Symbol rate (samples per second)
        args.Vpi: float
            Half-wave voltage of the MZM (V)
        args.P: float
            Power of the frequency comb signal (W)
        args.NFFT: int
            Number of points of the FFT (multiple of SpS)
        args.Fa: float
            Sampling frequency of the signal (samples per second)
        args.SpS: int
            Samples by each Rs
        args.n_peaks: int
            Number of peaks to be found (odd number)

    Returns:
    peaks: numpy array
        Peaks of the power spectrum of the frequency comb signal
    '''


    V1, V2, V3, Phase1, Phase2, Phase3, Vb2, Vb3 = params
    pi_Rs_t = 2 * np.pi * args.Rs * args.t
    K = np.pi / args.Vpi
    u1 = V1 * np.cos(pi_Rs_t + Phase1)
    u2 = V2 * np.cos(pi_Rs_t + Phase2)
    u3 = V3 * np.cos(pi_Rs_t + Phase3)
    cos_u1_K, sin_u1_K = np.cos(u1 * K), np.sin(u1 * K)
    cos_u2_Vb2_K = np.cos((0.5 * (u2 + Vb2)) * K)
    cos_u3_Vb3_K = np.cos((0.5 * (u3 + Vb3)) * K)
    frequency_comb = args.P * (cos_u1_K + 1j * sin_u1_K) * cos_u2_Vb2_K * cos_u3_Vb3_K
    psd = np.fft.fft(frequency_comb, n=args.NFFT)
    psd = np.fft.fftshift(psd)
    psd = np.abs(psd) ** 2 / (args.NFFT * args.Fa)
    psd[psd == 0] = np.finfo(psd.dtype).eps
    log_Pxx = 10 * np.log10(psd)
    n_peaks_2 = args.n_peaks // 2
    indx = (log_Pxx.shape[-1] // 2) + np.arange(-n_peaks_2, n_peaks_2 + 1, dtype=int) * (args.NFFT // args.SpS)
    peaks = log_Pxx[indx]
    return peaks


def optimization_flatComb_numpy(initial_guess, args, bounds, n_max = 100, method = "SLSQP"):

    ''' 
    Function to optimize the parameters of the frequency comb signal

    Parameters:
    initial_guess: list
        Initial guess for the parameters of the frequency comb signal
    args: parameters()
        Parameters object with the arguments to generate the frequency comb signal
        Should contain the following attributes: t, Rs, Vpi, P, NFFT, Fa, SpS, n_peaks
        args.t: numpy array
            Time vector
        args.Rs: float
            Symbol rate (samples per second)
        args.Vpi: float
            Half-wave voltage of the MZM (V)
        args.P: float
            Power of the frequency comb signal (W)
        args.NFFT: int
            Number of points of the FFT (multiple of SpS)
        args.Fa: float
            Sampling frequency of the signal (samples per second)
        args.SpS: int
            Samples by each Rs
        args.n_peaks: int
            Number of peaks to be found (odd number)

    bounds: list
        Bounds of the parameters
    n_max: int
        Max number of iterations
    method: string
        Optimization method: Nelder-Mead, Powell, L-BFGS-B, TNC, COBYLA, SLSQP, trust-constr

    Returns:
    optimized_params: list
        Optimized parameters of the frequency comb signal
    '''

    def objective_function(params, *args):

        peaks = analytical_function_compact_numpy(params, *args)
        var2 = np.var(peaks)**2
        
        return var2
    optimized_params = initial_guess
    n = 0
    while n < n_max:
        initial_guess = optimized_params
        result = minimize(objective_function, initial_guess, args = args, method=method, bounds = bounds)
        optimized_params = result.x
        
        peaks = analytical_function_compact_numpy(optimized_params, args)
        min_max = np.max(peaks) - np.min(peaks)

        if min_max < 1:
            break
        n += 1

    return optimized_params, peaks, min_max


def create_flatCombs_numpy(nsamples, args, bounds, upper_min_max = 5.0, n_max = 100, method = "COBYLA"):
    '''
    Function to create the flatComb datasets using scipy.optimize.minimize and NumPy

    Parameters:
    nsamples: int
        Number of samples to be created
    bounds: list
        Bounds of the parameters
    upper_min_max: float
        Maximum value of the peaks variance
    n_max: int
        Max number of iterations
    method: string
        Optimization method: Nelder-Mead, Powell, L-BFGS-B, TNC, COBYLA, SLSQP, trust-constr

    Returns:
    flatComb_inputs0_1dB: list
        Inputs of the flatComb dataset with peaks variance less than 1 dB
    flatComb_outputs0_1dB: list
        Outputs of the flatComb dataset with peaks variance less than 1 dB
    flatComb_inputs1_ndB: list
        Inputs of the flatComb dataset with peaks variance between 1 and n dB, where n is the upper_min_max
    flatComb_outputs1_ndB: list
        Outputs of the flatComb dataset with peaks variance between 1 and n dB, where n is the upper_min_max
        
    '''
    inputs = [[urand.Uniform(low, high).sample().item() for low, high in bounds] for _ in range(nsamples)]

    flatComb_inputs0_1dB = []
    flatComb_outputs0_1dB = []

    flatComb_inputs1_ndB = []
    flatComb_outputs1_ndB = []

    for input in inputs:
        best_params, peaks, min_max = optimization_flatComb_numpy(input, args, bounds, n_max, method)
        if min_max < 1:
            flatComb_inputs0_1dB.append(best_params)
            flatComb_outputs0_1dB.append(peaks)
        elif min_max < upper_min_max:
            flatComb_inputs1_ndB.append(best_params)
            flatComb_outputs1_ndB.append(peaks)

    return flatComb_inputs0_1dB, flatComb_outputs0_1dB, flatComb_inputs1_ndB, flatComb_outputs1_ndB
